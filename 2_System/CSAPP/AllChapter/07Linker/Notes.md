1. linking is combing various pieces of code into one file that can be loaded into memory and excecuted
2. linking can be performed at complie time, it translate source code into machine code
3. at load time, the loader load the program into memory and excecute
4. at run time, it even can do the same thing as that at load time
5. linking is automatically completed by linkers in moderen system
6. linker enable separate compilation
7. separate compilation can enable us to relink the modified files and files depend on them, which can faster compilation
8. 理解linking的好处
    * 构建大型程序：解决缺失模块，缺失库函数的问题
    * 避免程序错误：解决不同文件间变量的文件
    * 帮助理解scope
    * 帮助理解系统
    * 理解使用shared libraries
9. 本章讲解的知识点：
    * static linking and dynamic lingking
    * the performance and correctness impacted by linker
   
# 7.1 Compiler Drivers
1. compiler driver is a combination of:
    * language preprocessor
    * compiler
    * assembler
    * linker
2. gcc -v can see the complilation steps
3. 回忆第一章的编译过程流程图。不同阶段产生不同的文件，包含不同的内容


# 7.2 static linking
1. Static linkers such as the Linux ld program take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked executable object file that can be loaded and run.
2. The input relocatable object files consist of various code and data sections, where each section is a contiguous sequence of bytes
3. Instructions are in one section, initialized global variables are in another section, and uninitialized variables are in yet another section.
4. two main tasks of linker:
    * Symbolresolution. Objectfilesdefineandreferencesymbols,whereeach symbol corresponds to a function, a global variable, or a static variable. The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition.
    * Relocation. Compilers and assemblers generate code and data sections that start at address 0. The linker relocates these sections by associating a memory location with each symbol definition, and then modifying all of the references to those symbols so that they point to this memory location. The linker blindly performs these relocations using detailed instructions, generated by the assembler, called relocation entries.
5. basic facts about linkers:
    * Object files are merely collections of blocks of bytes. Some of these blocks contain program code, others contain program data, and others contain data structures that guide the linker and loader. 
    * A linker concatenates blocks together, decides on run-time locations for the concatenated blocks, and modifies various locations within the code and data blocks.
    * Linkers have minimal understanding of the target machine. The compilers and assemblers that generate the object files have already done most of the work.


# 7.3 Object Files
1. Object files come in three forms:
    * Relocatable object file. Contains binary code and data in a form that can be combined with other relocatable object files at compile time to create an executable object file.
    * Executable object file. Contains binary code and data in a form that can be copied directly into memory and executed.
    * Shared object file. A special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run time.
2. Compilers and assemblers generate relocatable object files (including shared object files)
3. Linkers generate executable object files.
4. object module is a sequence of bytes, and an object file is an object module stored on disk in a file.
5. Object files are organized according to specific object file formats, which vary from system to system.
6. Modern x86-64 Linux and Unix systems use Executable and Linkable Format (ELF).


# 7.4 Relocatable Object Files
1. Figure 7.3 show the format of an ELF relocatable object file
2. The ELF header begins with a 16-byte sequence that describes the word size and byte ordering of the system that generated the file.
3. The rest of the ELF header contains information that allows a linker to parse and interpret the object file. this include:
    * size of the ELF header
    * object file type (relocatable, executable, or shared)
    * machine type (x86-64)
    * file offset of the section header table
    * size and number of entries in the section header table.
4. The locations and sizes of the various sections are described by the section header table, which contains a fixed-size entry for each section in the object file.
5. Sandwiched between the ELF header and the section header table are the sections themselves
6. A typical ELF relocatable object file contains the following sections:
    * .text : The machine code of the compiled program.
    * .rodata : Read-only data such as the format strings in printf statements, and jump tables for switch statements.
    * .data : Initialized global and static C variables.
    * .bss : Uninitialized global and static C variables, along with any global or static variables that are initialized to zero.
    * .symtab : A symbol table with information about functions and global variables that are defined and referenced in the program.
    * .rel.text : A list of locations in the .text section that will need to be modified when the linker combines this object file with others. In general, any instruction that calls an external function or references a global variable will need to be modified.
    * .rel.data Relocationinformationforanyglobalvariablesthatarereferenced or defined by the module. In general, any initialized global variable whose initial value is the address of a global variable or externally defined func- tion will need to be modified.
    * .debug A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file. It is only present if the compiler driver is invoked with the -g option.
    * .line A mapping between line numbers in the original C source program and machine code instructions in the .text section. It is only present if the compiler driver is invoked with the -g option.
    * .strtab A string table for the symbol tables in the .symtab and .debug sec- tions and for the section names in the section headers. A string table is a sequence of null-terminated character strings.


# 7.5 Symbol and Symbol Tables
1. Each relocatable object module, m, has a symbol table that contains information about the symbols that are defined and referenced by m.
2. In the context of a linker, there are three different kinds of symbols:
    * . Global symbols that are defined by module m and that can be referenced by other modules. Global linker symbols correspond to nonstatic C functions and global variables.
    * Global symbols that are referenced by module m but defined by some other module. Such symbols are called externals and correspond to nonstatic C functions and global variables that are defined in other modules.
    * Local symbols that are defined and referenced exclusively by module m. These correspond to static C functions and global variables that are defined with the static attribute. These symbols are visible anywhere within module m, but cannot be referenced by other modules.
3. **It is important to realize that local linker symbols are not the same as local program variables.**
4. **The symbol table in .symtab does not contain any symbols that correspond to local nonstatic program variables. These are managed at run time on the stack and are not of interest to the linker.**
5. Interestingly, local procedure variables that are defined with the C static attribute are not managed on the stack. Instead, the compiler allocates space in .data or .bss for each definition and creates a local linker symbol in the symbol table with a unique name.
6. **(Symbol Table 的具体形式)**: Symbol tables are built by assemblers, using symbols exported by the compiler into the assembly-language .s file. An ELF symbol table is contained in the .symtab section. It contains an array of entries. Figure 7.4 shows the format of each entry.
7. contents:
    * The __name__ is a byte offset into the string table that points to the null-terminated string name of the symbol.
    * The __value__ is the symbol’s address. For relocatable modules, the value is an offset from the beginning of the section where the object is defined. For executable object files, the value is an absolute run-time address.
    * The __size__ is the size (in bytes) of the object.
    * The __type__ is usually either data or function.
    * The __binding__ field indicates whether the symbol is local or global.
8. Each symbol is assigned to some section of the object file, denoted by the __section__ field, which is an index into the section header table
9. There are three special pseudosections that don’t have entries in the section header table:
    * ABS is for sym- bols that should not be relocated.
    * UNDEF is for undefined symbols—that is, sym- bols that are referenced in this object module but defined elsewhere.
    * COMMON is for uninitialized data objects that are not yet allocated. For COMMON symbols, the value field gives the alignment requirement, and size gives the minimum size.
Note that these pseudosections exist only in relocatable object files; they do not exist in executable object files.
10. The GNU __readelf__ program is a handy tool for viewing the contents of object files.
11. readelf identifies each section by an integer index. Ndx=1 denotes the .text section, and Ndx=3 denotes the .data section.


# 7.6 Symbol Resolution
1. The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files.

**local symbol**
2. Symbol resolution is straightforward for references to local symbols that are de- fined in the same module as the reference.
3. The compiler allows only one definition of each local symbol per module.
4. The compiler also ensures that static local variables, which get local linker symbols, have unique names.

**global symbol**
**Resolving references to global symbols**
5. When the compiler encounters a symbol (either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, gener- ates a linker symbol table entry, and leaves it for the linker to handle.
6. If the linker is unable to find a definition for the referenced symbol in any of its input modules, it prints an (often cryptic) error message and terminates.
7. 一个理解 编译器报错 undefined symbol from some_module 的例子

**Symbol resolution for global symbols**
8. Symbol resolution for global symbols is also tricky because multiple object modules might define global symbols with the same name.
9. In this case, the linker must either flag an error or somehow choose one of the definitions and discard the rest. The approach adopted by Linux systems involves cooperation between the compiler, assembler, and linker and can introduce some baffling bugs to the unwary programmer.

**C++和JAVA的函数重载机制，与linker symbol 有关，阅读 P707 Aside。另外，C语言不支持函数重载，因为要求同一文件内，不准出现函数重名！**

### 7.6.1 How Linkers Resolve Duplicate Symbol Names
1. The input to the linker is a collection of relocatable object modules. Each of these modules defines a set of symbols, some of which are local (visible only to the module that defines it), and some of which are global (visible to other modules).
2. What happens if multiple modules define global symbols with the same name? Here is the approach that Linux compilation systems use.
    * At compile time, the compiler exports each global symbol to the assembler as either strong or weak, and the assembler encodes this information implicitly in the symbol table of the relocatable object file.
    * Functions and initialized global variables get strong symbols.
    * Uninitialized global variables get weak symbols.
    * Given this notion of strong and weak symbols, Linux linkers use the following rules for dealing with duplicate symbol names:
        * Rule 1. Multiple strong symbols with the same name are not allowed.
        * Rule2. Givenastrongsymbolandmultipleweaksymbolswiththesamename, choose the strong symbol.
        * Rule 3. Given multiple weak symbols with the same name, choose any of the weak symbols.

3. The application of rules 2 and 3 can introduce some insidious run-time bugs that are incomprehensible to the unwary programmer, especially if the duplicate symbol definitions have different types.
4. **P709 给出的例子，仔细阅读。在不同的文件声明同一变量，用不同的类型，可能会改写后续的内存数据，引发后续错误**
5. In a large system with hundreds of modules, a bug of this kind is extremely hard to fix, especially because many programmers are not aware of how linkers work, and because they often ignore compiler warnings.
6. **(实用 gcc 选项，帮助处理上述问题) When in doubt, invoke the linker with a flag such as the gcc -fno-common flag, which triggers an error if it encounters multiply- defined global symbols. Or use the -Werror option, which turns all warnings into errors.**
7. **解释 .bss 和 COMMON 为何只有细微差别，却同时存在两个集合的原因**P711
8. **习题 7.2 变量和函数重名？**


### 7.6.2 Linking with Static Libraries
1. So far, we have assumed that the linker reads a collection of relocatable object files and links them together into an output executable file.
2. In practice, all compilation systems provide a mechanism for packaging related object modules into a single file called a static library which can then be supplied as input to the linker.
3. When it builds the output executable, the linker copies only the object modules in the library that are referenced by the application program.
4. Consider the different approaches that compiler developers might use to pro- vide these functions to users without the benefit of static libraries.
5. One approach would be to have the compiler recognize calls to the standard functions and to generate the appropriate code directly.           but it is not feasible for C, because of the large number of standard functions defined by the C standard. It would add significant complexity to the compiler and would require a new compiler version each time a function was added, deleted, or modified.           To application programmers, however, this approach would be quite convenient because the standard functions would always be available.
6. Another approach would be to put all of the standard C functions in a single relocatable object module, say, libc.o, that application programmers could link into their executables:
```
gcc main.c /usr/lib/libc.o
```
7. This approach has the advantage that it would decouple the implementation of the standard functions from the implementation of the compiler, and would still be reasonably convenient for programmers.
8. **缺点1 耗费空间，因为每个程序都要复制 library 的对应模块**: a big disadvantage is that ev- ery executable file in a system would now contain a complete copy of the collection of standard functions, which would be extremely wasteful of disk space.
9. On our system, libc.a is about 5 MB and libm.a is about 2 MB
10. Worse, each running program would now contain its own copy of these functions in memory, which would be extremely wasteful of memory.
11. **缺点2 更新维护麻烦，每次更动库函数都要重新整体编译**: Another big disadvantage is that any change to any standard function, no matter how small, would require the library developer to recompile the entire source file, a time-consuming operation that would complicate the development and maintenance of the standard functions.
12. **解决方法**: We could address some of these problems by creating a separate relocatable file for each standard function and storing them in a well-known directory.
13. **但是需要靠程序员自己能力解决**: How- ever, this approach would require application programmers to explicitly link the appropriate object modules into their executables, a process that would be error prone and time consuming:
```
gcc main.c /usr/lib/printf.o    /usr/lib/scanf.o    ···
```
14. **引出static library的概念** The notion of a static library was developed to resolve the disadvantages of these various approaches
15. **Related functions can be compiled into separate object modules and then packaged in a single static library file.**
16. Application programs can then use any of the functions defined in the library by specifying a single filename on the command line.
```
gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```
17. At link time, the linker will only copy the object modules that are referenced by the program, which reduces the size of the executable on disk and in memory.
18. On the other hand, the application programmer only needs to include the names of a few library files. (In fact, C compiler drivers always pass libc.a to the linker, so the reference to libc.a mentioned previously is unnecessary.)
19. On Linux systems, static libraries are stored on disk in a particular file format known as an archive. An archive is a collection of concatenated relocatable object files, with a header that describes the size and location of each member object file. Archive filenames are denoted with the .a suffix.20. P713 静态链接的例子


### 7.6.3 How Linkers Use Static Libraries to Resolve References
1. **(写静态链接命令时， 库的位置顺序很重要！)** During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver’s command line.
2. During this scan the linker maintains
    * a set E of relocatable object files that will be merged to form the executable,
    * a set U of unresolved symbols (i.e., symbols referred to but not yet defined)
    * a set D of symbols that have been defined in previous input files
Initially, E, U, and D are empty.
3. 扫描过程算法流程
    * For each input file f on the command line, the linker determines if f is an object file or an archive. If f is an object file, the linker adds f to E, updates U and D to reflect the symbol definitions and references in f , and proceeds to the next input file.
    * If f is an archive, the linker attempts to match the unresolved symbols in U against the symbols defined by the members of the archive. If some archive member m defines a symbol that resolves a reference in U, then m is added to E, and the linker updates U and D to reflect the symbol definitions and references in m. This process iterates over the member object files in the archive until a fixed point is reached where U and D no longer change. At this point, any member object files not contained in E are simply discarded and the linker proceeds to the next input file.
    * If U is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in E to build the output executable file.
4. Unfortunately, this algorithm can result in some baffling link-time errors because the ordering of libraries and object files on the command line is significant.
5. **If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linking will fail**
6. **The general rule for libraries is to place them at the end of the command line.**
    * If the members of the different libraries are independent, in that no member references a symbol defined by another member, then the libraries can be placed at the end of the command line in any order.
    * If, on the other hand, the libraries are not independent, then they must be ordered so that for each symbol s that is referenced externally by a member of an archive, at least one definition of s follows a reference to s on the command line.
7. **Libraries can be repeated on the command line if necessary to satisfy the dependence requirements.**
8. 例子参见 P716


# 7.7 Relocation
1. Once the linker has completed the symbol resolution step, it has associated each symbol reference in the code with exactly one symbol definition (i.e., a symbol table entry in one of its input object modules)
2. At this point, the linker knows the exact sizes of the code and data sections in its input object modules. It is now ready to begin the relocation step, where it merges the input modules and assigns run-time addresses to each symbol.
3. Relocation consists of two steps:
    * Relocating sections and symbol definitions. In this step, the linker merges all sections of the same type into a new aggregate section of the same type. The linker then assigns run-time memory addresses to the new aggregate sections, to each section defined by the input modules, and to each symbol defined by the input modules. When this step is complete, each instruction and global variable in the program has a unique run-time memory address.
    * Relocating symbol references within sections. In this step, the linker modifies every symbol reference in the bodies of the code and data sections so that they point to the correct run-time addresses. To perform this step, the linker relies on data structures in the relocatable object modules known as relocation entries, which we describe next.

### 7.7.1 Relocation Entries
1. When an assembler generates an object module, it does not know where the code and data will ultimately be stored in memory. Nor does it know the locations of any externally defined functions or global variables that are referenced by the module.
2. So whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a relocation entry that tells the linker how to modify the reference when it merges the object file into an executable.
3. Relocation entries for code are placed in .rel.text. Relocation entries for data are placed in .rel.data.

略略略略略略略略略略略略略略
略略略略略略略略略略略略略略
略略略略略略略略略略略略略略






# 7.10 Dynamic Linking with Shared Libraries
1. (静态库的缺点) static libraries still have some significant disadvantages. Static libraries, like all software, need to be maintained and updated periodically. If ap- plication programmers want to use the most recent version of a library, they must somehow become aware that the library has changed and then explicitly relink their programs against the updated library.
2. (静态库的缺点)Another issue is that almost every C program uses standard I/O functions such as printf and scanf. At run time, the code for these functions is duplicated in the text segment of each running process. On a typical system that is running hundreds of processes, this can be a significant waste of scarce memory system resources.
3. (共享库的出现是为了解决静态库缺点的) Shared libraries are modern innovations that address the disadvantages of static libraries.
4. **A shared library is an object module that, at either run time or load time, can be loaded at an arbitrary memory address and linked with a program in memory**
5. This process is known as dynamic linking and is performed by a program called a dynamic linker
6. Shared libraries are also referred to as shared objects, and on Linux systems they are indicated by the .so suffix.
7. Shared libraries are “shared” in two different ways.
    * (需要引用共享库的文件，直接饮用，不需要复制共享库) First, in any given file system, there is exactly one .so file for a particular library. The code and data in this .so file are shared by all of the executable object files that reference the library, as opposed to the contents of static libraries, which are copied and embedded in the executables that reference them.
    * Second, a single copy of the .text section of a shared library in memory can be shared by different running processes. We will explore this in more detail when we study virtual memory in Chapter 9.
8. The basic idea is to do some of the linking statically when the executable file is created, and then complete the linking process dynami- cally when the program is loaded
9. It is important to realize that none of the code or data sections from libvector.so are actually copied into the executable prog2l at this point.
10. Instead, the linker copies some relocation and symbol table informa- tion that will allow references to code and data in libvector.so to be resolved at load time.


# 7.11 Loading and Linking Shared Libraries from Applications
1. However, it is also possible for an application to request the dynamic linker to load and link arbitrary shared libraries while the application is running, without having to link in the applications against those libraries at compile time.
2. Dynamic linking is a powerful and useful technique. Here are some examples in the real world:
    * Distributing software
    * Building high-performance Web servers
3. (共享库运行时加载和链接，对比调用子进程的优点) The idea is to package each function that generates dynamic content in a shared library. When a request arrives from a Web browser, the server dynamically loads and links the appropriate function and then calls it directly, as opposed to using fork and execve to run the function in the context of a child process. The function remains cached in the server’s address space, so subsequent requests can be handled at the cost of a simple function call. This can have a significant impact on the throughput of a busy site. Further, existing functions can be updated and new functions can be added at run time, without stopping the server.
4. Linux systems provide a simple interface to the dynamic linker that allows application programs to load and link shared libraries at run time.
    ```
#include <dlfcn.h>
    void *dlopen(const char *filename, int flag);
    // Returns: pointer to handle if OK, NULL on error
    ```
    1. The dlopen function loads and links the shared library filename.
    2. The external symbols in filename are resolved using libraries previously opened with the RTLD_ GLOBAL flag.
    3. If the current executable was compiled with the -rdynamic flag, then its global symbols are also available for symbol resolution.
    4. The flag argument must include either RTLD_NOW, which tells the linker to resolve references to external symbols immediately, or the RTLD_LAZY flag, which instructs the linker to defer symbol resolution until code from the library is executed. Either of these values can be ored with the RTLD_GLOBAL flag.

    ```
#include <dlfcn.h>
    void *dlsym(void *handle, char *symbol);
    // Returns: pointer to symbol if OK, NULL on error
    ```
    The dlsym function takes a handle to a previously opened shared library and a symbol name and returns the address of the symbol, if it exists, or NULL otherwise.

    ```
#include <dlfcn.h>
    int dlclose (void *handle);
    //Returns: 0 if OK, −1 on error
    ```
    The dlclose function unloads the shared library if no other shared libraries are still using it.

    ```
#include <dlfcn.h>
    const char *dlerror(void);
    // Returns: error message if previous call to dlopen, dlsym, or dlclose failed;
    // NULL if previous call was OK
    ```
    The dlerror function returns a string describing the most recent error that oc- curred as a result of calling dlopen, dlsym, or dlclose, or NULL if no error occurred.


5. Figure 7.17 一个使用动态链接的例子


# 7.12 Position Independent Code (PIC)
1. 用于解决共享库在多个进程中调用时，内存存储问题
2. PIC ：可以加载而无需重定位的代码

# 7.13 Library interpositioning
1. 共享库的高级技术


