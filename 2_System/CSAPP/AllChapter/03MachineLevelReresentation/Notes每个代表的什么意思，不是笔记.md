程序计数器（PC）用 **%rip** 表示！
# 3.1-3.4
1. Program Counter(PC): 程序计数器， 给出将要执行的下一条指令在内存中的地址
2. 整数寄存器，就是Figure3.2里的那些寄存器
3. 条件码寄存器，就是 contol 那一节里，为了给 com，test 命令集提供的值
4. 向量寄存器，应该是存放 floating 数据的寄存器
5. Figure3.2里的寄存器，只能用来存储整数类型！因为r开头的寄存器是64位的，所以也可以用来存储 指针(因为指针8字节)。另外提一点，注意区分，存进去的指针，是指针的值！如果要获得指针指向的对象，一般是用 (%r..) 表示取得 %r.. 指向的内存中的值！
6. 不同操作字节级的指令， 只能对寄存器对应从小到大那么多的字节进行操作，运算
7. 内存引用中，用于计算寻址的寄存器只能是 64bits 的寄存器(就是 %r 开头的寄存器)
8. 指令，一般是指 左面的被作用于 右面的。左面的是 source value，右面的是 destination value。所以一般是右面的存放最后的结果
9. 局部变量通常保存在寄存器中
10. movz 和 movs 的使用，决定于 source type 是 unsigned 还是 signed！
11. source 字节 大于等于 dest 可以直接使用 mov 类。决定最后一位的是 寄存器大小！寄存器大小必须与 mov最后一个字符代表的字节相同。因此不会存在 一个大寄存器给一个小寄存器 move 值。如果是 immediate 给 memory传值，就跟着 immediate变动
12. **做 Practice Problem 3.4。可以理解到，Figure3.2 里的寄存器只有十六个！对应十六行，十六个功能。至于每一行的那么多列，其实是每个64位寄存器中不同高位的截取值！！！**
13. stack是向下增长的！stack top的地址是stack中最低的！
 


# 3.5
1. 移位操作的移位数 operand 只能是 immediate 或者 %cl 寄存器


# 3.6 Control
1. 条件码，回忆最开始提到的，条件码寄存器，但是这些书中并没有重点提及，会使用 CMP TEST 指令判断即可
2. CMP 类似于算数中的 SUB， TEST 类似于算数中的 AND。但是都是根据结果，来设置相应的 条件码，然后用于后面的 JUMP 命令集
3. TEST可以理解为，就是把一个参数放在条件里（因为TEST的两个operand是一样的！）. 类似于 if (x) 这样的条件判断
4. JUMP 对于理解 Chapter7 的 Linking 和 理解 反汇编码 很重要
5. PC-relative！核心一句话，注意，这里提及的 jump 这条指令的编码，就是在可执行文件里 那几个字节的 编码(也对应 反汇编码的第二列！！！)。 计算方式：目标指令的地址 减去 紧跟在 jump 下一条指令的地址。
6. 学习 Practice Problem 3.15 中的习题 D，jump encoding 可以是四个字节！结合第二章的 little endian 进行解体
7. 3.6.6 conditional moves is a little bit complex to do reverse engineering
8. while loop. 区分 jump-to-middle 和 guard-do
9. Switch 的 jump table 书中感觉并没有讲清楚，怎么判断 default case，所以最后的两个 Practice Problem 也做不到，不过书中说了最重要的是知道，switch 使用了jump table进行了 jump！


# 3.7 Procedure
1. 调用函数三个大步骤：传递控制，传递数据，分配和释放内存
2. 通过栈顶指针 %rsp 实现分配和释放内存
3. 开始压入被调用函数的相关信息之前，会先压入调用函数的下一条指令地址！
4. ret 命令会把上一步中，存好的 返回地址在返回被调用函数时，弹出，PC会设置为该返回地址，实现了向回转移
5. 程序计数器（PC）用 **%rip** 表示！
6. Section3.7.5 %rbx, %rbp, %r12~%r15 称为callee save寄存器，用于保存调用函数的相关值，确保其不被改变！
7. 其他的寄存器，除了 %rsp，都被称为 caller save 寄存器，callee可以修改他们，也可以使用。负责保存这些数据的是 caller 的责任。


# 3.9 Structure
1. Union 可以给大型的数据结构使用，节省空间开销(不过容易造成bug)
2. 可以用来访问不同数据类型的位模式, 因为强制转换，会对位造成改变(会自动计算对应的值)。但是union直接在位改变和访问，不会改变对应的位
3. 注意，little endian 和 big endian 中，union中访问时，字节的顺序
4. data alignment, 数据对齐，有利于机器进行访问内存。提高效率

# 3.10 data and control
1. 缓存区溢出的汇编码解释！理解P308-P309里字符串读取的内部机制。 如果字符串读超过8个（即开始缓存区溢出）。因为这些函数都是在 stack 里进行的，并且stack只会向下分配（就是地址减小）。然后第一个字符被读入是从 stack top 进行的！！！后续的字符读入存储的空间，就依次向 stack 内部延伸。导致可能修改到 ret 需要调用的，在call时存储的 返回值地址！！！！！！！！！
2. 木马和病毒的攻击方式！利用程序的bug (比如这里讨论的，用读取字符覆盖之前的 return 地址)，然后 return 到木马和病毒 程序的地址，对木马和病毒进行调用！

**防止系统漏洞，木马病毒攻击的安全机制**
随机化stack
1. 随机化 stack ，可以随机化地址(虚拟地址)，让指向木马病毒代码的指针难以预测
2. 随机化实验，最后三个字节没有变化，以及开头五个字节没有变化！变化的是中间四个字节！
3. 破解方法， nop ，但是没看懂

哨兵值法
1. 在调用函数时，每次随机产生一个值，插入在 stack frame 中的 局部缓冲区 与 stak状态之间。检查返回函数时，该值是否被修改

限制内存可执行代码的部分


**Practice Problem 3.49, 学习变长stack frame，比较难，而且需要结合第二章的知识理解**

# 3.11 Floating-Point Code
1. 






