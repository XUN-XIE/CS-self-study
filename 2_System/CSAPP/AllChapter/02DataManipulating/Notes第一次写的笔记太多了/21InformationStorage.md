1. We consider the three most important representations of numbers.
    * Unsigned encodings are based on traditional binary notation, representing numbers greater than or equal to 0.
    * Two’s-complement encodings are the most common way to represent signed integers, that is, numbers that may be either positive or negative.
    * Floating-point encodings are a base-2 version of scientific notation for represent- ing real numbers.
2. Computer representations use a limited number of bits to encode a number, and hence some operations can overflow when the results are too large to be rep- resented. This can lead to some surprising results.
3. On the other hand, integer computer arithmetic satisfies many of the familiar properties of true integer arithmetic. The computer might not generate the expected result, but at least it is con- sistent!
4. Floating-point arithmetic has altogether different mathematical properties. The product of a set of positive numbers will always be positive, although over- flow will yield the special value +∞.
5. **Floating-point arithmetic is not associative due to the finite precision of the representation.**
6. The different mathematical properties of integer versus floating-point arithmetic stem from the difference in how they handle the finiteness of their representations—integer representations can encode a compar- atively small range of values, but do so precisely, while floating-point representa- tions can encode a wide range of values, but only approximately.
7. (作用) By studying the actual number representations, we can understand the ranges of values that can be represented and the properties of the different arithmetic operations.
8. **(满足可移植性) This understanding is critical to writing programs that work correctly over the full range of numeric values and that are portable across different combi- nations of machine, operating system, and compiler.**
9. Computers use several different binary representations to encode numeric values. You will need to be familiar with these representations as you progress into machine-level programming in Chapter 3.
10. (对理解机器码也有帮助) We derive several ways to perform arithmetic operations by directly ma- nipulating the bit-level representations of numbers. Understanding these tech- niques will be important for understanding the machine-level code generated by compilers in their attempt to optimize the performance of arithmetic expression evaluation.
11. The C++ programming language is built upon C, using the exact same numeric representations and operations. Everything said in this chapter about C also holds for C++.


### Aside How to read this chapter
1. (阅读建议) 
To help you navigate this exposition, we have structured the presentation to first state a property as a principle in mathematical notation. We then illustrate this principle with examples and an informal discussion. We recommend that you go back and forth between the statement of the principle and the examples and discussion until you have a solid intuition for what is being said and what is important about the property. For more complex properties, we also provide a derivation, structured much like a mathematical proof. You should try to understand these derivations eventually, but you could skip over them on first reading.


## 2.1 Information Storage
1. Rather than accessing individual bits in memory, most computers use blocks of 8 bits, or bytes, as the smallest addressable unit of memory.
2. A machine-level program views memory as a very large array of bytes, referred to as virtual memory.
3. Every byte of memory is identified by a unique number, known as its address, and the set of all possible addresses is known as the virtual address space.
4. As indicated by its name, this virtual address space is just a conceptual image presented to the machine-level program.
5. The actual implementation (presented in Chapter 9) uses a combination of dynamic random access memory (DRAM), flash memory, disk storage, special hardware, and operating system software to provide the program with what appears to be a monolithic byte array.
6. Various mechanisms are used to allocate and manage the storage for different parts of the program. This management is all performed within the virtual address space.
7. the value of a pointer in C—whether it points to an integer, a structure, or some other program object—is the virtual address of the first byte of some block of storage.
8. The C compiler also associates type information with each pointer, so that it can generate different machine-level code to access the value stored at the location designated by the pointer depending on the type of that value.
9. Although the C compiler maintains this type information, the actual machine-level program it generates has no information about data types. It simply treats each program object as a block of bytes and the program itself as a sequence of bytes.


### Aside The evolution of the C programming language
1. The GNU Compiler Collection (gcc) can compile programs according to the conventions of several different versions of the C language, based on different command-line options, as shown in Figure 2.1. For example, to compile program prog.c according to ISO C11, we could give the command line
```
linux> gcc -std=c11 prog.c
```
2. The options -ansi and -std=c89 have identical effect—the code is compiled according to the ANSI or ISO C90 standard. The option -std=c99 causes the compiler to follow the ISO C99 convention.
3. The GNU project is developing a version that combines ISO C11, plus other features, that can be specified with the command-line option -std=gnu11. (Currently, this implementation is incomplete.) This will become the default version.

### Aside The role of pointers in C
1. Pointers are a central feature of C. They provide the mechanism for referencing elements of data structures, including arrays. Just like a variable, a pointer has two aspects: its value and its type. The value indicates the location of some object, while its type indicates what kind of object (e.g., integer or floating-point number) is stored at that location.
2. Truly understanding pointers requires examining their representation and implementation at the machine level. This will be a major focus in Chapter 3, culminating in an in-depth presentation in Section 3.10.1.


### 2.1.1 Hexadecimal Notation
1. (二进制和十进制都太麻烦了，不适合描述 bit pattern) Instead, we write bit patterns as base-16, or hexadecimal numbers.
2. In C, numeric constants starting with 0x or 0X are interpreted as being in hexadecimal. The characters ‘A’ through ‘F’ may be written in either upper- or lowercase. We will use the C notation for representing hexadecimal values in this book.
3. A common task in working with machine-level programs is to manually con- vert between decimal, binary, and hexadecimal representations of bit patterns.
4. **(一个小技巧) When a value x is a power of 2, that is, x = 2^n for some nonnegative integer n, we can readily write x in hexadecimal form by remembering that the binary representation of x is simply 1 followed by n zeros. The hexadecimal digit 0 represents 4 binary zeros. So, for n written in the form i + 4j , where 0 ≤ i ≤ 3, we can write x with a leading hex digit of 1 (i=0), 2 (i=1), 4 (i=2), or 8 (i = 3), followed by j hexadecimal 0s. As an example, for x = 2,048 = 211, we have n = 11 = 3 + 4 . 2, giving hexadecimal representation 0x800.**  (主要掌握的是 2 的 n 次方，这个 n 怎么快速准换换为十六进制的表示，因为 2^n 只有第 n + 1 位有1，其他都是零，所以 n = i + 4 * j, j 表示的是十六进制中的0的个数，十六进制一个0等于二进制4个0！！！所以再用 i 对应上 1，2，4，8中的一个数，分别是 0>1, 1>2, 2>4,4>8, 相当于 有 i 位0二进制在缀在前面，记住最前位为1(因为一共 n + 1 位二进制)) (说的太复杂了，害，自己复习一看就懂了)

(十进制和十六进制互相转换，其实和二进制转换差不多)
5. Converting between decimal and hexadecimal representations requires using multiplication or division to handle the general case. To convert a decimal num- ber x to hexadecimal, we can repeatedly divide x by 16, giving a quotient q and a remainder r, such that x = q . 16 + r. We then use the hexadecimal digit represent- ing r as the least significant digit and generate the remaining digits by repeating the process on q.
6. Conversely, to convert a hexadecimal number to decimal, we can multiply each of the hexadecimal digits by the appropriate power of 16. For example, given the number 0x7AF, we compute its decimal equivalent as 7 . 162 + 10 . 16 + 15 = 7 . 256 + 10 . 16 + 15 = 1,792 + 160 + 15 = 1,967.


### 2.1.2 Data Sizes
1. **(虚拟地址空间的range是跟着点用位数走的，比如64位。类似于64位的int类型，可以存储多大的数，那么虚拟地址的range就是多大！因为每个不同的值，代表一个不同的pointer！！！一个pointer就可以指向一个地址，所以就有那么多的虚拟地址空间！！！) Every computer has a word size, indicating the nominal size of pointer data. Since a virtual address is encoded by such a word, the most important system parameter determined by the word size is the maximum size of the virtual address space. That is, for a machine with a w-bit word size, the virtual addresses can range from 0 to 2^(w − 1), giving the program access to at most 2^w bytes.**
2. (64位电脑也可以支持32位的模拟运算！！！) Most 64-bit machines can also run programs compiled for use on 32-bit ma- chines, a form of backward compatibility. So, for example, when a program prog.c is compiled with the directive
```
linux> gcc -m32 prog.c
```
3. **(分清这个概念，位数的程序和位数的电脑机器是不一样的！)We will therefore refer to programs as being either “32-bit programs” or “64-bit programs,” since the distinction lies in how a program is compiled, rather than the type of machine on which it runs.**
4. (高位数电脑，也可以支持低字节表达的integer和float) Computers and compilers support multiple data formats using different ways to encode data, such as integers and floating point, as well as different lengths. For example, many machines have instructions for manipulating single bytes, as well as integers represented as 2-, 4-, and 8-byte quantities. They also support floating-point numbers represented as 4- and 8-byte quantities.
5. (C支持多种类型，但是具体每个类型的字节还得看编译选项！) The C language supports multiple data formats for both integer and floating- point data. The exact numbers of bytes for some data types depends on how the program is compiled.
6. **(有特殊类型在所有机器上的字节长度是固定的, 另一方面讲提高了可移植性？) To avoid the vagaries of relying on “typical” sizes and different compiler set- tings, ISO C99 introduced a class of data types where the data sizes are fixed regardless of compiler and machine settings. Among these are data types int32_t and int64_t, having exactly 4 and 8 bytes, respectively. Using fixed-size integer types is the best way for programmers to have close control over data represen- tations.**
7. (可移植性问题) Programmers should strive to make their programs portable across different machines and compilers. One aspect of portability is to make the program insensi- tive to the exact sizes of the different data types. The C standards set lower bounds on the numeric ranges of the different data types, as will be covered later, but there are no upper bounds (except with the fixed-size types). 
8. (历史遗留问题) With 32-bit machines and 32-bit programs being the dominant combination from around 1980 until around 2010, many programs have been written assuming the allocations listed for 32- bit programs in Figure 2.3. With the transition to 64-bit machines, many hidden word size dependencies have arisen as bugs in migrating these programs to new machines. For example, many programmers historically assumed that an object declared as type int could be used to store a pointer. This works fine for most 32-bit programs, but it leads to problems for 64-bit programs.


### 2.1.3 Addressing and Byte Ordering
1. For program objects that span multiple bytes, we must establish two conventions: what the address of the object will be, and how we will order the bytes in memory.
2. (数据在虚拟内存中的存储方式) In virtually all machines, a multi-byte object is stored as a contiguous sequence of bytes, with the address of the object given by the smallest address of the bytes used. **(理解这个例子，会想vscode里debug的过程，每个变量显示的地址！对应上了) For example, suppose a variable x of type int has address 0x100; that is, the value of the address expression &x is 0x100. Then (assuming data type int has a 32-bit representation) the 4 bytes of x would be stored in memory locations 0x100, 0x101, 0x102, and 0x103.**
3. For ordering the bytes representing an object, there are two common conven- tions.
4. (两种存放 bit representation 的方式，一个是把最重要位先存放，一个把最不重要位先存放) Consider a w-bit integer having a bit representation [xw−1, xw−2, . . . , x1, x0], where xw−1 is the most significant bit and x0 is the least. Assuming w is a multiple of 8, these bits can be grouped as bytes, with the most significant byte having bits [xw−1, xw−2, . . . , xw−8], the least significant byte having bits [x7, x6, . . . , x0], and the other bytes having bits from the middle. Some machines choose to store the ob- ject in memory ordered from least significant byte to most, while other machines store them from most to least. The former convention—where the least significant byte comes first—is referred to as little endian. The latter convention—where the most significant byte comes first—is referred to as big endian.
**看图！看图！看图！lettle endian有惊喜**
5. (这是处理器级别的区别，不同的公司用的方式一样) Most Intel-compatible machines operate exclusively in little-endian mode. On the other hand, most machines from IBM and Oracle (arising from their acquisition of Sun Microsystems in 2010) operate in big-endian mode. 
6. Many recent microprocessor chips are bi-endian, meaning that they can be configured to operate as either little- or big-endian machines.
7. In practice, however, byte ordering becomes fixed once a particular operating system is chosen.
8. (一般来说对程序员来讲没有影响) For most application programmers, the byte orderings used by their machines are totally invisible; programs compiled for either class of machine give identi- cal results.
9. **(有影响的地方和问题, 网络编程时) At times, however, byte ordering becomes an issue. The first is when binary data are communicated over a network between different machines. A common problem is for data produced by a little-endian machine to be sent to a big-endian machine, or vice versa, leading to the bytes within the words being in reverse order for the receiving program. To avoid such problems, code written for networking applications must follow established conventions for byte order- ing to make sure the sending machine converts its internal representation to the network standard, while the receiving machine converts the network standard to its internal representation. We will see examples of these conversions in Chap- ter 11.**
10. **(第二个有影响的饿方法和问题, 正是我们在学的 integer representation，要是没关系作者也不会讲这个知识点啊) A second case where byte ordering becomes important is when looking at the byte sequences representing integer data. This occurs often when inspecting machine-level programs.**
11. (第二个问题的例子，看书，设计到机器码) For now, we simply note that this line states that the hexadecimal byte sequence 01 05 43 0b 20 00 is the byte-level representation of an instruction that adds a word of data to the value stored at an address computed by adding 0x200b43 to the current value of the program counter, the address of the next instruction to be executed. If we take the final 4 bytes of the sequence 43 0b 20 00 and write them in reverse order, we have 00 20 0b 43. Dropping the leading 0, we have the value 0x200b43, the numeric value written on the right. Having bytes appear in reverse order is a common occurrence when reading machine-level program representations generated for little-endian machines such as this one. The natural way to write a byte sequence is to have the lowest-numbered byte on the left and the highest on the right, but this is contrary to the normal way of writing numbers with the most significant digit on the left and the least on the right.
12. **(第三个有影响的地方和问题，C内的强制类型转换机制) A third case where byte ordering becomes visible is when programs are written that circumvent the normal type system. In the C language, this can be done using a cast or a union to allow an object to be referenced according to a different data type from which it was created. Such coding tricks are strongly discouraged for most application programming, but they can be quite useful and even necessary for system-level programming.**


# 代码分析(首先明确一个根本问题，地址在C中的类型是什么？十六进制的整型数！！！)
1. 首先明确 unsinged char 是一个字节！十六进制的两位，二进制的八位！
2. 所以 show_bytes里 printf的格式是 %.2x ，因为刚好两位的十六进制
3. 下面三个接口函数，普遍分析，首先在第一个参数位置，使用casting 强制转换 Type指针类型 为unsigned char * 类型，因此原本在 Type指针类型里地址是 Type字节数，现在改成都为 char 的一个字节，所以可以分开打印！第二个参数，在调用 sizeof 计算 Type 的字节数，表示我们遍历时需要的次数。
4. 换一种方式理解，其实可以直接调用 printf 中的 %p 格式打印出地址，只不过作者的目的是拆分 每个类型的指针的每个字节
5. 再思考，int * 是4字节，char * 是一字节，所以强制转化的时候，把 int * 拆分成了 四个 char * , ！！！关键点是， 第一个函数的里的 start[i] 不要当成是指针数组去理解！！！ 当作是在做 start + i 理解，这样就是每次start在首地址 移动了 i 次个 char * 的字节数！！！
6. 第一个函数打印出来的内容就是 输入的数值的 十六进制表达式！ 比如输入 1 输出就是 01 00 00 00！(因为粗心又忘了一个重点！) 注意 start[i] 另一个作用相当于 解索引！ 所这是在取值！！！ 结合第五点的讨论。 这里是 对start 每次移动一个字节，然后对现在处于的字节取出对应的值！！！
**经过这个程序的洗礼和思考，应该转变一下对C/C++指针类型的使用和理解了！应该尽可能的想成是字节跳动！当成字节去思考，才能细致理解到系统和C！**


#### Aside Generating an ASCII table
1. You can display a table showing the ASCII character code by executing the command man ascii.


### 2.1.4 Representing Strings
1. A string in C is encoded by an array of characters terminated by the null (having value 0) character. Each character is represented by some standard encoding, with the most common being the ASCII character code.
2. (Thus, if we run our routine show_bytes with arguments "12345" and 6 (to include the terminating character), we get the result 31 32 33 34 35 00. Observe that the ASCII code for decimal digit x happens to be 0x3x, and that the terminating byte has the hex representation 0x00. This same result would be obtained on any system using ASCII as its character code, independent of the byte ordering and word size conventions. As a consequence, text data are more platform independent than binary data.)
**如果把"123456"传入上一节中的 show_bytes 里打印出来的结果就是 ascii 码中 '1'2'3'4'5'6' 分别对应的 hex 代号**


### 2.1.5 Representing Code
1. **(不同机器上相同的函数调用，产生的binary file是不同的) Different machine types use different and incompatible instructions and encodings. Even identical proces- sors running different operating systems have differences in their coding conven- tions and hence are not binary compatible. Binary code is seldom portable across different combinations of machine and operating system.**
2. A fundamental concept of computer systems is that a program, from the perspective of the machine, is simply a sequence of bytes. The machine has no information about the original source program, except perhaps some auxiliary tables maintained to aid in debugging. We will see this more clearly when we study machine-level programming in Chapter 3.



#### Web Aside DATA:BOOL(C 没有 bool 类型！！！)
1. Boolean algebra has many of the same properties as arithmetic over integers. For example, just as multiplication distributes over addition, written a . (b + c) = (a . b) + (a . c), Boolean operation & distributes over |, written a & (b | c) = (a & b) | (a & c). In addition, however. Boolean operation | distributes over &, and so we can write a | (b & c) = (a | b) & (a | c), whereas we cannot say that a + (b . c) = (a + b) . (a + c) holds for all integers.
2. When we consider operations ^, &, and ~ operating on bit vectors of length w, we get a different mathematical form, known as a Boolean ring. Boolean rings have many properties in common with integer arithmetic.
3. A similar property holds for Boolean rings, where ^ is the “addition” operation, but in this case each element is its own additive inverse. That is, a ^ a = 0 for any value a, where we use 0 here to represent a bit vector of all zeros. This property holds even when we rearrange terms and combine them in a different order, and so (a ^ b) ^ a = b. This property leads to some interesting results and clever tricks, as we will explore in Problem 2.10.



### 2.1.6 Introduction to Boolean Algebra
1. Since binary values are at the core of how computers encode, store, and manipu- late information, a rich body of mathematical knowledge has evolved around the study of the values 0 and 1.
2. One useful application of bit vectors is to represent finite sets. We can encode anysubsetA⊆{0,1,...,w−1}withabitvector[aw−1,...,a1,a0],whereai =1if and only if i ∈ A. 例子:  a = [01101001] encodes the set A = {0, 3, 5, 6}, b = [01010101] encodes the set B = {0, 2, 4, 6}. a，b分别从右往左的index，依次对应A，B中存在的数。 **the operation a & b yields bit vector [01000001], while A ∩ B = {0, 6}.**
3. We will see the encoding of sets by bit vectors in a number of practical applications. in Chapter 8, we will see that there are a number of different signals that can interrupt the execution of a program. We can selectively enable or disable different signals by specifying a bit-vector mask, where a 1 in bit position i indicates that signal i is enabled and a 0 indicates that it is disabled. Thus, the mask represents the set of enabled signals.
 

### 2.1.7 Bit-Level Operations in C
1. (位运算只能作用在C语言的所有类整数型上)One useful feature of C is that it supports bitwise Boolean operations. In fact, the symbols we have used for the Boolean operations are exactly those used by C: | for or, & for and, ~ for not, and ^ for exclusive-or. These can be applied to any “integral” data type, including all of those listed in Figure 2.3.
2. As our examples show, the best way to determine the effect of a bit-level ex- pression is to expand the hexadecimal arguments to their binary representations, perform the operations in binary, and then convert back to hexadecimal.
 As our examples show, the best way to determine the effect of a bit-level ex- pression is to expand the hexadecimal arguments to their binary representations, perform the operations in binary, and then convert back to hexadecimal.

  As our examples show, the best way to determine the effect of a bit-level ex- pression is to expand the hexadecimal arguments to their binary representations, perform the operations in binary, and then convert back to hexadecimal.

   As our examples show, the best way to determine the effect of a bit-level ex- pression is to expand the hexadecimal arguments to their binary representations, perform the operations in binary, and then convert back to hexadecimal.
3. Pratice Problem 2.10 巧用 ^ 进行swap操作
4. One common use of bit-level operations is to implement masking operations, where a mask is a bit pattern that indicates a selected set of bits within a word.
5. As an example, the mask 0xFF (having ones for the least significant 8 bits) indicates the low-order byte of a word. The bit-level operation x & 0xFF yields a value consisting of the least significant byte of x, but with all other bytes set to 0. For example, with x = 0x89ABCDEF, the expression would yield 0x000000EF.


### 2.1.9 Shift Operations in C(只能对int相关类型进行 shift，char也可以，浮点数不可以)
1. C also provides a set of shift operations for shifting bit patterns to the left and to the right.
2. x << k, That is, x is shifted k bits to the left, dropping off the k most significant bits and filling the right end with k zeros.
3. **Shift operations associate from left to right, so x << j << k is equivalent to (x << j) << k.**
4. **分两种**
    * Logical. A logical right shift fills the left end with k zeros, giving a result [0, . . . , 0, xw−1, xw−2, . . . xk].
    * Arithmetic. An arithmetic right shift fills the left end with k repetitions of the most significant bit, giving a result [xw−1, . . . , xw−1, xw−1, xw−2, . . . xk]. This convention might seem peculiar, but as we will see, it is useful for operating on signed integer data.
5. **(C不确保上述中的两个使用哪一个！导致可移植性的问题，所以就别用) The C standards do not precisely define which type of right shift should be used with signed numbers—either arithmetic or logical shifts may be used. This unfortunately means that any code assuming one form or the other will potentially encounter portability problems.**
6. **In practice, however, almost all compiler/machine combinations use arithmetic right shifts for signed data, and many programmers assume this to be the case. For unsigned data, on the other hand, right shifts must be logical.**


#### Aside Shifting by k, for large values of k
1. The C standards carefully avoid stating what should be done in such a case. On many machines, the shift instructions consider only the lower log2 w bits of the shift amount when shifting a w-bit value, and so the shift amount is computed as k mod w.
2. This behavior is not guaranteed for C programs, however, and so shift amounts should be kept less than the word size.
3. Java, on the other hand, specifically requires that shift amounts should be computed in the modular fashion we have shown.

#### Aside Operator precedence issues with shift operations
1. It might be tempting to write the expression 1<<2 + 3<<4, intending it to mean (1<<2) + (3<<4). How- ever, in C the former expression is equivalent to 1 << (2+3) << 4, since addition (and subtraction) have higher precedence than shifts. The left-to-right associativity rule then causes this to be parenthesized as (1 << (2+3)) << 4, giving value 512, rather than the intended 52.
2. Getting the precedence wrong in C expressions is a common source of program errors, and often these are difficult to spot by inspection. When in doubt, put in parenthe




 
