/*************************************************************************
 @Author: XieXun
 @Created Time : Mon  7 Dec 02:01:54 2020
 @File Name: main.c
 @Description: 第六题全逻辑结构，因为太长了，还一堆的循环
 ************************************************************************/
#include <stdio.h>

int main()
{
    int nums[6] = { 1,2,3,4,5,6 }; 
    int *r14 = nums;
    int r12 = 0;
    int *r13 = nums;
    // 这里有 一个 eax 的指针，储存 6 个 int
    
    // 第一个循环的逻辑是， 遍历数组确定数组的每个值互不相等
    while (true)
    {
        int * rbp = r13;
        int eax = *r13;
        eax -= 1;
        // ！！！！！！！！！！！！！！这里的 eax <= 5 必须！！！！！！！！！！
        // r12 就是数组的 index
        r12 += 1;
        // 等于说这是在遍历数组
        if (r12 == 6)
            break;
        else
        {
            // ebx 是 当前外循环 指向的index
            int ebx = r12;
            while (ebx <= 5)
            {
                eax = ebx;
                eax = *(rsp + 4 * eax);
                // !!!!!!!!!!!!!!!!!! 这里 *(rbp) != %eax !!!!!!!!!!!!
                // 这个要求的意思是 6 个数字不能相等
                ebx += 1;
            }
        }
    }
    // 数组的 end 地址
    int *rsi = rsp + 24;
    // 数组的开始位置地址
    eax = r14;
    int ecx = 7;

    // 又是一个遍历, 目的是 对每一个数值， 改变为 7 - element
    while (eax != rsi)
    {
        int edx = ecx;  // 
        edx -= *eax;    // 
        *eax = edx;
        eax += 4;
    }

    // 数组的 index
    int esi = 0;
    // 第一个 element
    ecx = *(nums + esi);
    while (ecx <= 1)
    {
        int edx = 0x6032d0;
        // 这个和数组的关系，是在另外的地方 赋值
        // 是这个总体函数， 80 stack 里，从 32 开始 到 80 全部赋值其他东西
        
        // 每次 占用 8 个字节
        *(nums + 2 * esi + 32) = edx;
        esi += 4;
        // 六次循环？
        if (esi == 24)
        {
            这里准确的说不是 break， 是 跳到 100 行！
            break;
        }//
        else
            // 对 ecx 按顺序 把数组中的值赋给它
            ecx = *(nums + esi);
    }

    eax = 1;
    edx = 0x6032d0;
    // 上面循环退出时，ecx 肯定大于1
    // 然后在这里 用 edx 表示 退出时 ecx 和 1 之间的差距，数组所指向的字符串！！！！
    while (eax != ecx)
    {
        edx = *(edx + 8);
        eax += 1;
    }

    跳回！69 行！
///////////////////////////////// 总结上面 51 --- 93 行的逻辑思维。在 %rsp + 32 --- %rsp + 80 的位置中，存放入 字符串！每个字符串字节为8。存放的方式是：
// 如果 对应的数组值 大小 为 小于等于 1， 则重复使用 edx地址 中存放的字符串； 如果大于 1 的，则会 按照 与 1 的差值，对 edx 地址 进行 8 * diff 的就散。然后再对 edx地址 取值，赋给 字符串的那一大块

        // 这些存完了，都是数字了！数字的值！不是地址值！


        
    // 初始化为 字符串组中的第一个字符串
    ebx = *(nums + 32);
    // 字符串组中 第二个字符串的开始地址
    eax = nums + 40;
    // 结束地址
    esi = nums + 80;
    // ecx 指向 第一个字符串的值
    ecx = ebx;
   
    // 这个循环的目的是 把前一个节点和后一个连接上！
    while (true)
    {
        // 从之前储存的字符串中的 第二个 开始！
        edx = *eax;
        // 更改存储的字符串的 值
        // 从这一行，结合 对应地址的值， 可以知道 ecx 取出来的都是 地址形式的值！而不是小整数值！！！解题用
        // 然后改变 地址 下一个的那个整数值 改为
        // ecx, edx 都必须是地址形式的值？
        
        // 后面 第一个字符串值 指向的地址发生了改变！
        
        // 第二个字符串存储的地址值 赋给了 第一个字符串存储的地址值 + 8 
        // 地址指向关系打乱了！！！
        *(ecx + 8) = edx;
        eax += 8;
        if (eax == esi)
            break;
        // 
        ecx = edx;
    }
    // rsp + 80 终止地址设为值 0
    *(edx + 8) = 0;
    ebp = 5;
    
    // 遍历
    while (ebp != 0)
    {
        // ebx 是字符串组的第一个字符串
        // eax 是第二个字符串（地址值）
        eax = *(ebx + 8);
        // 再取地址值对应的值
        eax = *eax;
        /////////////////// *ebx >= eax !!!!!!!!!!!!!!!!!!!!!!!!
        
        // ebx 向后遍历
        ebx = *(ebx + 8);
        ebp -= 1;
    }
    // 可以判断出 题目的要求是 字符串组中，前面的字符串地址指向的值必须大于或等于后面的相邻的值




}
